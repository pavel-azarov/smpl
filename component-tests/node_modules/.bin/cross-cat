#!/usr/bin/env node
"use strict";
/*
    File: src/cross-cat.ts
    cpuabuse.com
*/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Entry point for the project.
 */
/**
 * @license ISC
 * ISC License (ISC)
 *
 * Copyright 2020 cpuabuse.com
 *
 * Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
const commander_1 = require("commander");
const get_stdin_1 = __importDefault(require("get-stdin"));
const show_ends_1 = require("./pipeline/show-ends");
const number_1 = require("./pipeline/number");
const number_nonblank_1 = require("./pipeline/number-nonblank");
const squeeze_blank_1 = require("./pipeline/squeeze-blank");
const show_tabs_1 = require("./pipeline/show-tabs");
const fs_1 = require("fs");
/**
 * Literal empty string.
 */
const emptyString = "";
const stdinFilename = "-";
// The variable is too big to have a copy, thus we override no-param-reassign
/**
 * A function performing file processing, mocking behavoir of linux cat function.
 * @param filename File name
 */
function cat(text, flags) {
    // Process squeeze blank lines
    if (flags.squeezeBlankFlag) {
        text = squeeze_blank_1.processSqueezeBlank(text); // eslint-disable-line no-param-reassign
    }
    // Processing to show tabs
    if (flags.showTabsFlag) {
        text = show_tabs_1.processTabs(text); // eslint-disable-line no-param-reassign
    }
    // Processing to show line numbers
    if (flags.numberNonblankFlag) {
        text = number_nonblank_1.processNumberNonBlank(text); // eslint-disable-line no-param-reassign
        // Processing to show line endings
        if (flags.showEndsFlag) {
            text = show_ends_1.processEnds(text); // eslint-disable-line no-param-reassign
        }
    }
    else {
        // Processing to show line endings
        if (flags.showEndsFlag) {
            text = show_ends_1.processEnds(text); // eslint-disable-line no-param-reassign
        }
        if (flags.numberFlag) {
            text = number_1.processNumber(text); // eslint-disable-line no-param-reassign
        }
    }
    // Print result to the console
    log(text);
}
/**
 * Prints a text.
 * @param text Text to print.
 */
function log(text) {
    // eslint-disable-next-line no-console
    process.stdout.write(text);
}
/**
 * Prints error to console.
 */
function error(text) {
    // eslint-disable-next-line no-console
    process.stderr.write(`Error: ${text}`);
}
/**
 * Process the args.
 */
async function parseArgs() {
    let program = new commander_1.Command();
    // Program metadeta
    program.version("0.0.1");
    program.description(`Concatenate FILE(s) to standard output.

With no FILE, or when FILE is -, read standard input.`);
    program.on("--help", function () {
        // eslint-disable-next-line no-console
        console.log(`
Examples:
    cat f - g  Output f's contents, then standard input, then g's contents.
    cat        Copy standard input to standard output.`);
    });
    // Create new promise for filenames; Used promise for fucntion structure, even though no async code run
    let filenames = new Promise(function (resolve) {
        // Get files; The method action is synchronous.
        program.arguments("[filenames...]").action(function (argFiles) {
            // Resolve the promise
            resolve(argFiles.length > 0 ? argFiles : [stdinFilename]);
        });
    });
    // Initialize flags
    program.option("-A, --show-all", "equivalent to -vET");
    program.option("-b, --number-nonblank", "number nonempty output lines, overrides -n");
    program.option("-e", "equivalent to -vE");
    program.option("-E, --show-ends", "display $ at end of each line");
    program.option("-n, --number", "number all output lines");
    program.option("-s, --squeeze-blank", "supress repeated empty output lines");
    program.option("-t", "equivalent to -vT");
    program.option("-T, --show-tabs", "display TAB characters as ^I");
    program.option("-u", "(ignored)");
    program.option("-v, --show-nonprinting", "use ^ and M- notation, except for LFD and TAB");
    program.parse(process.argv);
    /**
     * Checks if the flag is set to true.
     */
    function checkFlag(flag) {
        if (Object.prototype.hasOwnProperty.call(program, flag)) {
            if (program[flag] === true) {
                return true;
            }
        }
        return false;
    }
    // TODO: Check that verions from parser and -v options do not conflict
    return {
        filenames: await filenames,
        numberFlag: checkFlag("number"),
        numberNonblankFlag: checkFlag("numberNonblank"),
        showAllFlag: checkFlag("showAll"),
        showEndsFlag: checkFlag("showEnds"),
        showNonprintingFlag: checkFlag("showNonprinting"),
        showTabsFlag: checkFlag("showTabs"),
        squeezeBlankFlag: checkFlag("squeezeBlank"),
        stdin: process.stdin.isTTY ? await get_stdin_1.default() : emptyString
    };
}
/**
 * Main function.
 */
async function main() {
    // Stdin read or not
    let stdinRead = false;
    // Contains concatenated files
    let text = emptyString;
    // Parses the args
    let parsedArgs = await parseArgs();
    // Promises for texts
    let promises = new Array();
    // File reading loop
    try {
        parsedArgs.filenames.forEach(function (filename) {
            promises.push(new Promise(function (resolve, reject) {
                if (filename === stdinFilename) {
                    resolve(stdinRead ? emptyString : parsedArgs.stdin);
                    stdinRead = true;
                }
                else {
                    fs_1.readFile(filename, function (err, data) {
                        if (err) {
                            reject(filename);
                        }
                        else {
                            resolve(data.toString());
                        }
                    });
                }
            }));
        });
        for (let i = 0; i < promises.length; i++) {
            // For big files await in loop will increase speed
            text += await promises[i]; // eslint-disable-line no-await-in-loop
        }
    }
    catch (filename) {
        error(`Could not open the file - ${filename}`);
        return;
    }
    cat(text, parsedArgs);
}
// Calling main
main();
//# sourceMappingURL=cross-cat.js.map